## Local database and containers

The database engine we are going to use is called CockroachDB. 
It is a modern, Cloud-native, distributed SQL database.

- we are going to use the Docker image for *CockroachDB* and run it in a container.
- *CockroachDB* is compatible with PostgreSQL to a significant extent, 
- The Go modules that work with _Postgres_, 
- such as _pgx, pq, GORM,_ and _upper/db_ also work with *CockroachDB*.
[CockroachDB documentatio](https://www.cockroachlabs.com/docs/v20.2/build-a-go-app-with-cockroachdb.html)

### Storage

The point of a database is to have a persistent store of data. 
Volumes are the preferred mechanism for persisting data generated by and used by Docker containers. 
Thus, before we start CockroachDB, let’s create the volume for it.

* To create a managed volume, run :
```
$ docker volume create roach
```
We can view the list of all managed volumes in our Docker instance with the following c
```
$ docker volume list
```
### Networking
we are going to use what is called a user-defined bridge network. 
It is going to provide us with a DNS lookup service,
so that we can refer to our database engine container by its hostname.
The following command creates a new bridge network named mynet:
```
gming@mintsys:~/docker$  docker network create -d bridge mynet
7c3d188c6db27f942385ecd69ef7d61eabeac660339fd56ef158738296940617
gming@mintsys:~/docker$ docker network list
NETWORK ID     NAME      DRIVER    SCOPE
d287b2093d26   bridge    bridge    local
2990771a4d9e   host      host      local
7c3d188c6db2   mynet     bridge    local
1dd4b8ebfefd   none      null      local

```
### Choose good names for volumes and networks
When choosing a name for a network or a managed volume, 
it’s best to choose a name that is indicative of the intended purpose. 
In this module, though, we aimed for brevity, so we settled for short, generic names.

#### Start the database engine
```
 docker run -d \
  --name roach \
  --hostname db \
  --network mynet \
  -p 26257:26257 \
  -p 8080:8080 \
  -v roach:/cockroach/cockroach-data \
  cockroachdb/cockroach:latest-v20.1 start-single-node \
  --insecure

 ```
### Configure the database engine

Now that the database engine is live, there is some configuration to do before our application can begin using it. Fortunately, it’s not a lot. We must:

1. Create a blank database.
2. Register a new user account with the database engine.
3. Grant that new user access rights to the database.

```
$  docker exec -it roach ./cockroach sql --insecure
```
* In the SQL shell, create the database that our example application is going to use:
```
    CREATE DATABASE mydb;
```
*  Register a new SQL user account with the database engine. We pick the username totoro.
```
    CREATE USER totoro;
```
* Give the new user the necessary permissions:
```
    GRANT ALL ON DATABASE mydb TO totoro;
```
* Type ```quit``` to exit the shell.

* An example of interaction with the SQL shell is presented below.
```
#
# Welcome to the CockroachDB SQL shell.
# All statements must be terminated by a semicolon.
# To exit, type: \q.
#
# Server version: CockroachDB CCL v20.1.17 (x86_64-unknown-linux-gnu, built 2021/05/17 16:34:52, go1.13.9) (same version as client)
# Cluster ID: cf1e870f-1172-4379-9199-39a068215697
#
# Enter \? for a brief introduction.
#
root@:26257/defaultdb> CREATE DATABASE mydb;
CREATE DATABASE
Time: 20.227892ms
root@:26257/defaultdb> CREATE USER totoro;
CREATE ROLE
Time: 11.157167ms
root@:26257/defaultdb> GRANT ALL ON DATABASE mydb TO totoro;
GRANT
Time: 10.816248ms
root@:26257/defaultdb> quit
```

* Build the application

We can build the image with the familiar build command:
```
$ docker build --tag docker-gs-ping-roach .
```

* Run the application
```
**Note**
  * Since we are running our CockroachDB cluster in “insecure” mode, 
  * the value for the password can be anything.
  * Don’t run in insecure mode in production, though!
```
 docker run -it --rm -d \
  --network mynet \
  --name rest-server \
  -p 80:8080 \
  -e PGUSER=totoro \
  -e PGPASSWORD=myfriend \
  -e PGHOST=db \
  -e PGPORT=26257 \
  -e PGDATABASE=mydb \
  docker-gs-ping-roach
  ```
  
  ```
  gming@mintsys:~/docker/docker-gs-ping-roach$  docker run -it --rm -d \
>   --network mynet \
>   --name rest-server \
>   -p 80:8080 \
>   -e PGUSER=totoro \
>   -e PGPASSWORD=myfriend \
>   -e PGHOST=db \
>   -e PGPORT=26257 \
>   -e PGDATABASE=mydb \
>   docker-gs-ping-roach
575bc628cae66e77e7996f3a6b438ab2fa823f60c6fd0830fc3512e49b90261e
gming@mintsys:~/docker/docker-gs-ping-roach$ curl localhost
Hello, Docker! (0)
```
```
gming@mintsys:~/docker/docker-gs-ping-roach$ curl http://localhost/
Hello, Docker! (0)
```
* The total number of stored messages is ```0``` for now. 
- This is fine, because we had not posted anything to our application yet.

* We refer to the database container by its hostname, 
- which is ```db```. This is what we had the ```--name db``` for when we started the database container.

* The actual password does not matter, 
- but it must be set to something to avoid confusing the example application.

* The container we’ve just run is named ```rest-server```. 
- These names are useful for managing the container lifecycle:

```
gming@mintsys:~/docker/docker-gs-ping-roach$ curl --request POST \
>   --url http://localhost/send \
>   --header 'content-type: application/json' \
>   --data '{"value": "Hello, Docker!"}'
{"value":"Hello, Docker!"}
```
The application responds with the contents of the message, 
which means it had been saved in the database:
```
{"value":"Hello, Docker!"}
```
Let’s send another message:

```
gming@mintsys:~/docker/docker-gs-ping-roach$ curl --request POST \
> --url http://localhost/send \
> --header 'content-type: application/json' \
> --data '{"value": "Hello, Oliver!"}'
{"value":"Hello, Oliver!"}
gming@mintsys:~/docker/docker-gs-ping-roach$ curl localhost
Hello, Docker! (2)
```

Hey, that’s exactly right! We sent two messages and the database kept them. 
Or has it? Let’s stop and remove all our containers, but not the volumes, and try again.

First, let’s stop the containers:
```
gming@mintsys:~/docker/docker-gs-ping-roach$ docker container stop rest-server roach
rest-server
roach
```
Then, let’s remove them:
```
$ docker container rm rest-server roach
```
Verify they are gone:
```
gming@mintsys:~/docker/docker-gs-ping-roach$ docker container list --all
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
```
And start them again, database first:
```
$ docker run -d \
  --name roach \
  --hostname db \
  --network mynet \
  -p 26257:26257 \
  -p 8080:8080 \
  -v roach:/cockroach/cockroach-data \
  cockroachdb/cockroach:latest-v20.1 start-single-node \
  --insecure
 ```
 And the service next:
 
 ```
 docker run -it --rm -d \
  --network mynet \
  --name rest-server \
  -p 80:8080 \
  -e PGUSER=totoro \
  -e PGPASSWORD=myfriend \
  -e PGHOST=db \
  -e PGPORT=26257 \
  -e PGDATABASE=mydb \
  docker-gs-ping-roach
```
Lastly, let’s query our service:

``` 
gming@mintsys:~/docker/docker-gs-ping-roach$ curl localhost
Hello, Docker! (2)
```
### Wind down everything

* Remember, that we are running CockroachDB in “insecure” mode. Now that we had built and tested our application,
* You can list the containers that you are running with the list command:

```
gming@mintsys:~/docker/docker-gs-ping-roach$ docker container list
CONTAINER ID   IMAGE                                COMMAND                  CREATED         STATUS         PORTS                                                                                      NAMES
6f131f22b7b4   docker-gs-ping-roach                 "/docker-gs-ping-roa…"   5 minutes ago   Up 5 minutes   0.0.0.0:80->8080/tcp, :::80->8080/tcp                                                      rest-server
596bef6bad08   cockroachdb/cockroach:latest-v20.1   "/cockroach/cockroac…"   5 minutes ago   Up 5 minutes   0.0.0.0:8080->8080/tcp, :::8080->8080/tcp, 0.0.0.0:26257->26257/tcp, :::26257->26257/tcp   roach
```
* Now that you know the container IDs, 
* you can use ```docker container stop``` and ```docker container rm```, 
* as demonstrated in the previous modules.

* Please make sure that you stop the _CockroachDB_ and _docker-gs-ping-roach_ containers before moving on.

### Better productivity with Docker Compose

In this section, 
we’ll create a Docker Compose file to start our _docker-gs-ping-roach_ application and
_CockroachDB_ database engine with a single command.

### The ```.env``` file

Docker Compose will automatically read environment variables from a ```.env``` file if it is available. 
Since our Compose file requires ```PGPASSWORD``` to be set, we add the following content to the ```.env``` file:
```
PGPASSWORD=whatever
```
The exact value does not really matter for our example, 
because we run CockroachDB in ```insecure``` mode, 
but we have to set the variable to some value to avoid getting an error.

### Validating Docker Compose configurations
```
$ docker-compose config
```
